
### 一：事务的特性（ACID）

+ 原子性（Atomicity）

+ 一致性（Consistency）

+ 隔离性（Isolation）

+ 持久性（Durability）

### 二：事务并发操作可能出现的问题

+ 脏读

+ 不可重复读

+ 幻读


### 三：事务的隔离级别

+ 读未提交（Read uncommitted）

    一个事务可以读取到另一个事务未提交的数据
    
    会产生`脏读`的问题
    
    ````
    1：A事务修改一个数据，未提交
    2：B事务读取了A事务未提交的数据
    3：A事务对数据进行了回滚操作    

+ 读已提交（Read committed）

    一个事务只可以读取另一个事务已提交的数据
    
    可以避免脏读，但会有`不可重复读`的问题
    
    ````
    1：A事务读取一个数据值为 x
    2：B事务将数据修改为 y
    3：A事务再次读取数据，发现数据已经由 x 变为了 y

+ 可重复读（Repeatable read）

    重复读，就是在开始读取数据（事务开启）时，不再允许其他事务进行修改操作
    
    可以避免不可重复读，但会有`幻读`的问题
    
    注意：不可重复读对应的是修改，幻读对应的是插入
    
    但其实mysql在默认的可重复读隔离级别下，是不会有幻读的问题的

    

+ 序列化读（Serializable ）

    事务串行化顺序执行，可以避免脏读、不可重复读与幻读
    
    但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用


### 四：事务的传播行为
   
   + 1： REQUIRED（默认）
   
    支持使用当前事务，如果当前事务不存在，创建一个新事务。
    
   + 2：REQUIRES_NEW
  
    创建一个新事务，如果当前事务存在，把当前事务挂起。
    
   + 3：SUPPORTS
   
    支持使用当前事务，如果当前事务不存在，则不使用事务。
    有事务就使用事务，没有就不使用事务。
    
   + 4：MANDATORY
   
    中文翻译为强制，支持使用当前事务，如果当前事务不存在，则抛出Exception。
    

   + 5：NOT_SUPPORTED（与 SUPPORTS）
   
    无事务执行，如果当前事务存在，把当前事务挂起。意思是不需要使用事务
   + 6：NEVER
   
    不需要事务，如果当前有事务则抛出Exception。
    
    
   + 7：NESTED
   
    嵌套事务，如果当前事务存在，那么在嵌套的事务中执行。
    如果当前事务不存在，则表现跟REQUIRED一样。
    
### 五：悲观锁和乐观锁    
